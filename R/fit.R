##' Fit exponential models to incidence data
##'
##' This function fits two exponential models to incidence data, of the form:
##' \eqn{log(y)} = r * t + b
##'
##' where 'y' is the incidence, 't' is time (in days), 'r' is the growth rate, and 'b' is the
##' origin. The function \code{fit} will fit one model by default, but will fit two models on either side of a splitting data if the argument \code{split} is provided.
##'
##' @export
##'
##' @rdname fit
##'
##' @author Thibaut Jombart \email{thibautjombart@@gmail.com}
##'
##' @seealso the \code{\link{incidence}} function to generate the 'incidence' objects.
##'
##' @param x An incidence object, generated by the function \code{\link{incidence}}. For the
##' plotting function, an \code{incidence.fit} object.
##'
##' @param split An optional time point identifying the separation between the two models. If NULL,
##' a single model is fitted. If provided, two models would be fitted on the time periods on either
##' side of the split.
##'
##' @param level The confidence interval to be used for predictions; defaults to 95\%.
##'

## The model fitted is a simple linear regression on the log-incidence.

## Non-trivial bits involve:

## 1) Fitting several models
## I.e. in case there is a increasing and a decreasing phase, we fit one
##  model for each phase separately.

## 2) log(0)
## No satisfying solutions so far; for now removing the NAs

## 3) Several groups
## In this case, the number of models does not change, but models automatically
## include groups with interaction, whether or not it is significant.

fit <- function(x, split = NULL, level = 0.95){
    ## enforce minimum counts !! THIS BIASES THE MODEL A LOT
    ## min.count <- 1e-10
    ## x$counts[x$counts < min.count] <- min.count
    n.groups <- ncol(x$counts)

    ## remove dates with one incidence of zero
    to.keep <- apply(x$counts, 1, min) > 0
    if (!all(to.keep)) {
        warning(sprintf("%d dates with an incidence of 0 were removed before fitting",
                sum(!to.keep)))
    }
    x <- x[to.keep]

    ## model without split (1 model)
    if (is.null(split)) {
        df <- as.data.frame(x, long=TRUE)
        df$dates.int <- as.integer(df$dates - min(df$dates))

        if (n.groups == 1) {
            lm1 <- stats::lm(log(counts) ~ dates.int, data = df)
        } else {
            lm1 <- stats::lm(log(counts) ~ dates.int * groups, data = df)
        }
        out <- extract.info(lm1, x, level)
        out$dates <- df$dates
    } else {
        x1 <- x[x$dates <= split]
        x2 <- x[x$dates >= split]
        df1 <- as.data.frame(x1, long=TRUE)
        df2 <- as.data.frame(x2, long=TRUE)

        df1$dates.int <- as.integer(df1$dates - min(df1$dates))
        df2$dates.int <- as.integer(df2$dates - min(df2$dates))
                if (n.groups == 1) {
                    lm1 <- stats::lm(log(counts) ~  dates.int, data = df1)
                    lm2 <- stats::lm(log(counts) ~  dates.int, data = df2)
                } else {
                    lm1 <- stats::lm(log(counts) ~  dates.int * groups, data = df1)
                    lm2 <- stats::lm(log(counts) ~  dates.int * groups, data = df2)
                }
        before <- extract.info(lm1, x, level)
        before$dates <- x1$dates
        after <- extract.info(lm2, x, level)
        after$dates <- x2$dates
        out <- list(before = before, after = after)
    }

    out
}





##' @export
##' @rdname fit
##' @param window The size, in days, of the time window either side of the split.
##' @param plot A logical indicating whether a plot should be added to the output, showing the mean
##' R2 for various splits.

fit.optim.split <- function(x, window = x$timespan/4, plot = TRUE){
    date.peak <- x$dates[which.max(x$counts[,1])] # !! this assumes a single group
    try.since <- date.peak - window / 2
    try.until <- date.peak + window / 2
    to.keep <- x$dates >= try.since & x$dates <= try.until
    if (sum(to.keep) < 1) {
        stop("No date left to try after defining splits to try.")
    }

    splits.to.try <- x$dates[to.keep]

    f <- function(split) {
        fits <- suppressWarnings(fit(x, split=split))
        mean(vapply(fits, function(e) summary(e$lm)$`adj.r.squared`, double(1)))
    }

    results <- sapply(splits.to.try, f)

    ## shape output
    df <- data.frame(dates = splits.to.try, mean.R2 = results)
    split <- splits.to.try[which.max(results)]
    fit <- fit(x, split = split)
    out <- list(df = df,
                split = split,
                fit = fit)

    if (plot) {
        out$plot <- ggplot2::ggplot(df, ggplot2::aes_string(x = "dates", y = "mean.R2")) +
            ggplot2::geom_point() + ggplot2::geom_line() +
                ggplot2::geom_text(ggplot2::aes_string(label="dates"), hjust=-.1, angle=35) +
                    ggplot2::ylim(min=min(results)-.1, max=1)
    }

    out
}





## Non-exported function extracting info and predictions from a lm object
## - reg is a lm object
## - x is an incidence object
## - level is a confidence level, defaulting to .95

extract.info <- function(reg, x, level){
    if (is.null(reg)) {
        return(NULL)
    }

    ## extract growth rates (r)
    ## here we need to keep all coefficients when there are interactions
    to.keep <- grep("^dates.int.*$", names(stats::coef(reg)), value=TRUE)
    r <- stats::coef(reg)[to.keep]
    use.groups <- length(r) > 1
    if (use.groups) {
        names(r) <- reg$xlevels[[1]] # names = levels if groups
    } else {
        names(r) <- NULL # no names otherwise
    }
    r.conf <- stats::confint(reg, to.keep, level)
    rownames(r.conf) <- names(r)
    if (use.groups) {
        r[-1] <- r[-1] + r[1] # add coefs to intercept
        r.conf[-1,] <- r.conf[-1,] + r.conf[1,] # add coefs to intercept
    }


    ## need to pass new data spanning all dates and groups here
    if (use.groups) {
        new.data <- expand.grid(sort(unique(reg$model$dates.int)), levels(reg$model$groups))
        names(new.data) <- c("dates.int", "groups")
    } else {
        new.data <- data.frame(dates.int = sort(unique(reg$model$dates.int)))
    }
    pred <- exp(stats::predict(reg, newdata = new.data, interval = "confidence",
                                   level = level))
    pred <- cbind.data.frame(new.data, pred) # keep track of dates and groups for plotting
    info <- list(r = r, r.conf = r.conf,
                 pred = pred)

    if (r[1] > 0 ) { # note: choice of doubling vs halving only based on 1st group
        info$doubling <- log(2) / r
        info$doubling.conf <- log(2) / r.conf
        o.names <- names(info$doubling.conf)
        info$doubling.conf <-rev(info$doubling.conf)
        names(info$doubling.conf) <- o.names
    } else {
        info$halving <- log(0.5) / r
        info$halving.conf <- log(0.5) / r.conf
        o.names <- names(info$halving.conf)
        info$halving.conf <-rev(info$halving.conf)
        names(info$halving.conf) <- o.names
    }

    out <- list(lm = reg, info = info)
    class(out) <- "incidence.fit"
    out
}






##' @export
##' @rdname fit
##' @param ... further arguments passed to other methods (not used)

print.incidence.fit <- function(x, ...) {

  cat("<incidence.fit object>\n\n")
  cat("$lm: regression of log-incidence over time\n\n")

  cat("$info: list containing the following items:\n")
  cat(sprintf("  $r: %.5f (daily growth rate)\n", x$info$r))
  cat(sprintf("  $r.conf: [%.5f ; %.5f] (confidence interval)\n",
              x$info$r.conf[1], x$info$r.conf[2]))
  if (x$info$r[1] > 0) {
      cat(sprintf("  $doubling: %.1f (doubling time in days)\n", x$info$doubling))
      cat(sprintf("  $doubling.conf: [%.1f ; %.1f] (confidence interval)\n",
                  x$info$doubling.conf[1], x$info$doubling.conf[2]))
  } else {
      cat(sprintf("  $halving: %.1f (halving time in days)\n", x$info$halving))
      cat(sprintf("  $halving.conf: [%.1f ; %.1f] (confidence interval)\n",
                  x$info$halving.conf[1], x$info$halving.conf[2]))
  }

  cat(sprintf("  $pred: %d predictions of incidence\n", length(x$info$pred)))
  cat(sprintf("  $pred.conf: %d x %d matrix of predictions (confidence interval)\n",
      nrow(x$info$pred.conf), ncol(x$info$pred.conf)))


  invisible(x)
}





## This function will take an existing 'incidence' plot object ('p') and add lines from an
## 'incidence.fit' object ('x')

add.incidence.fit <- function(p, x){
    df <- cbind.data.frame(dates = x$dates, x$info$pred)

    p <- suppressMessages(p + ggplot2::geom_line(data = df,
                                                   ggplot2::aes_string(x = "dates", y = "fit"), linetype = 1) +
                            ggplot2::geom_line(data = df,
                                               ggplot2::aes_string(x = "dates", y = "lwr"), linetype = 2) +
                            ggplot2::geom_line(data = df,
                                               ggplot2::aes_string(x = "dates", y = "upr"), linetype = 2)
                            )
    p
}





##' @export
##' @rdname fit
##' @importFrom graphics lines
##' @inheritParams plot.incidence

plot.incidence.fit <- function(x, ..., col.pal = pal1){
    df <- cbind.data.frame(dates = x$dates, x$info$pred)
    out <- ggplot2::ggplot(df, ggplot2::aes_string(x = "dates")) +
        ggplot2::geom_line(ggplot2::aes_string(y = "fit"), linetype = 1) +
            ggplot2::geom_line(ggplot2::aes_string(y = "lwr"), linetype = 2) +
            ggplot2::geom_line(ggplot2::aes_string(y = "upr"), linetype = 2)

    if ("groups" %in% names(df)) {
        n.groups <- length(levels(df$groups))
        out <- out + ggplot2::aes_string(color = "groups") +
            ggplot2::scale_color_manual(values = col.pal(n.groups))
    }
    out + ggplot2::labs(x = "", y = "Predicted incidence")
}
