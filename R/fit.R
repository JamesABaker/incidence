##' Fit exponential models to incidence data
##'
##' This function fits two exponential models to incidence data, of the form:
##' \eqn{log(y)} = r * t + b
##'
##' where 'y' is the incidence, 't' is time (in days), 'r' is the growth rate, and 'b' is the
##' origin. The function \code{fit} will fit one model by default, but will fit two models on either side of a splitting data if the argument \code{split} is provided.
##'
##' @export
##'
##' @rdname fit
##'
##' @author Thibaut Jombart \email{thibautjombart@@gmail.com}
##'
##' @seealso the \code{\link{incidence}} function to generate the 'incidence' objects.
##'
##' @param x An incidence object, generated by the function \code{\link{incidence}}.
##'
##' @param split An optional time point identifying the separation between the two models. If NULL,
##' a single model is fitted. If provided, two models would be fitted on the time periods on either
##' side of the split.
##'
##' @param level The confidence interval to be used for predictions; defaults to 95\%.
##'

## The model fitted is a simple linear regression on the log-incidence.

## Non-trivial bits involve:

## 1) Fitting several models
## I.e. in case there is a increasing and a decreasing phase, we fit one
##  model for each phase separately.

## 2) log(0)
## For now we use an arbitrary replacement (1e-10)
fit <- function(x, split = NULL, level = 0.95){
    min.count <- 1e-10
    x$counts <- as.numeric(x$counts)
    x$counts[x$counts < min.count] <- min.count

    if (is.null(split)) {
        dates.int <- seq_along(x$dates) - 1
        lm1 <- stats::lm(log(x$counts) ~ dates.int)
        out <- extract.info(lm1, x$interval, level)
        out$dates <- x$dates
    } else {
        x1 <- x[x$dates <= split]
        x2 <- x[x$dates >= split]
        dates.int1 <- seq_along(x1$dates) - 1
        dates.int2 <- seq_along(x2$dates) - 1
        lm1 <- stats::lm(log(x1$counts) ~  dates.int1)
        lm2 <- stats::lm(log(x2$counts) ~  dates.int2)
        before <- extract.info(lm1, x$interval, level)
        before$dates <- x1$dates
        after <- extract.info(lm2, x$interval, level)
        after$dates <- x2$dates
        out <- list(before = before, after = after)
    }

    out
}





##' @export
##' @rdname fit
##' @param window The size, in days, of the time window either side of the split.
##' @param plot A logical indicating whether a plot should be added to the output, showing the mean
##' R2 for various splits.

fit.optim.split <- function(x, window = x$timespan/4, plot = TRUE){
    date.peak <- x$dates[which.max(x$counts[,1])] # !! this assumes a single group
    try.since <- date.peak - window / 2
    try.until <- date.peak + window / 2
    to.keep <- x$dates >= try.since & x$dates <= try.until
    if (sum(to.keep) < 1) {
        stop("No date left to try after defining splits to try.")
    }

    splits.to.try <- x$dates[to.keep]

    f <- function(split) {
        fits <- fit(x, split=split)
        mean(vapply(fits, function(e) summary(e$lm)$`adj.r.squared`, double(1)))
    }

    results <- sapply(splits.to.try, f)

    ## shape output
    df <- data.frame(dates = splits.to.try, mean.R2 = results)
    split <- splits.to.try[which.max(results)]
    fit <- fit(x, split = split)
    out <- list(df = df,
                split = split,
                fit = fit)

    if (plot) {
        out$plot <- ggplot2::ggplot(df, ggplot2::aes_string(x = "dates", y = "mean.R2")) +
            ggplot2::geom_point() + ggplot2::geom_line() +
                ggplot2::geom_text(ggplot2::aes_string(label="dates"), hjust=-.1, angle=35) +
                    ggplot2::ylim(min=min(results)-.1, max=1)
    }

    out
}





## Non-exported function extracting info and predictions from a lm object

extract.info <- function(reg, interval, level){
    if (is.null(reg)) {
        return(NULL)
    }

    r <- unname(stats::coef(reg)[2])
    r.conf <- stats::confint(reg, 2, level)
    rownames(r.conf) <- NULL

    r.day <- r / interval
    r.day.conf <- r.conf / interval

    pred <- exp(stats::predict(reg))
    pred.conf <- exp(stats::predict(reg, interval = "confidence", level = level)[,2:3])

    info <- list(r = r, r.conf = r.conf,
                r.day = r.day, r.day.conf = r.day.conf,
                pred = pred, pred.conf = pred.conf)

    if (r.day > 0 ) {
        info$doubling <- log(2) / r.day
        info$doubling.conf <- log(2) / r.day.conf
        o.names <- names(info$doubling.conf)
        info$doubling.conf <-rev(info$doubling.conf)
        names(info$doubling.conf) <- o.names
    } else {
        info$halving <- log(0.5) / r.day
        info$halving.conf <- log(0.5) / r.day.conf
        o.names <- names(info$halving.conf)
        info$halving.conf <-rev(info$halving.conf)
        names(info$halving.conf) <- o.names
    }

    out <- list(lm = reg, info = info)
    class(out) <- "incidence.fit"
    out
}






##' @export
##' @rdname fit
##' @param ... further arguments passed to other methods (not used)

print.incidence.fit <- function(x, ...) {

  cat("<incidence.fit object>\n\n")
  cat("$lm: regression of log-incidence over time\n\n")

  cat("$info: list containing the following items:\n")
  cat(sprintf("  $r.day: %.5f (daily growth rate)\n", x$info$r.day))
  cat(sprintf("  $r.day.conf: [%.5f ; %.5f] (confidence interval)\n",
              x$info$r.day.conf[1], x$info$r.day.conf[2]))
  if (x$info$r > 0) {
      cat(sprintf("  $doubling: %.1f (doubling time in days)\n", x$info$doubling))
      cat(sprintf("  $doubling.conf: [%.1f ; %.1f] (confidence interval)\n",
                  x$info$doubling.conf[1], x$info$doubling.conf[2]))
  } else {
      cat(sprintf("  $halving: %.1f (halving time in days)\n", x$info$halving))
      cat(sprintf("  $halving.conf: [%.1f ; %.1f] (confidence interval)\n",
                  x$info$halving.conf[1], x$info$halving.conf[2]))
  }

  cat(sprintf("  $pred: %d predictions of incidence\n", length(x$info$pred)))
  cat(sprintf("  $pred.conf: %d x %d matrix of predictions (confidence interval)\n",
      nrow(x$info$pred.conf), ncol(x$info$pred.conf)))


  invisible(x)
}





## This function will take an existing 'incidence' plot object ('p') and add lines from an
## 'incidence.fit' object ('x')

add.incidence.fit <- function(p, x){
    df <- data.frame(dates = rep(x$dates, 3),
                     type = factor(rep(c("pred", "low", "high"), each=length(x$dates))),
                     y = c(x$info$pred, x$info$pred.conf[,1], x$info$pred.conf[,2])
                     )

    ## Note: adding several geoms without calling ggplot2::ggplot() will fail
    ## because the "+" operator will not work
    out <- suppressMessages(p +
                            ggplot2::geom_line(data = df, ggplot2::aes_string(x = "dates", y = "y", linetype = "type")) +
         ggplot2::scale_linetype_manual(guide=FALSE, values=c(pred=1, low=2, high=2))
                            )
    out
}





##' @export
##' @rdname fit
##' @importFrom graphics lines

plot.incidence.fit <- function(x, ...){
    df <- data.frame(dates = rep(x$dates, 3),
                     type = factor(rep(c("pred", "low", "high"), each=length(x$dates))),
                     y = c(x$info$pred, x$info$pred.conf[,1], x$info$pred.conf[,2])
                     )
    out <- ggplot2::ggplot(df, ggplot2::aes_string(x = "dates")) +
        ggplot2::geom_line(data = df, ggplot2::aes_string(y = "y", linetype = "type")) +
         ggplot2::scale_linetype_manual(guide=FALSE, values=c(pred=1, low=2, high=2))
    out
}
